// __Pruning the tree based on generated scores__
def ConstrainPropagation:
	set score = 0 (_initially_)
	create list scoreList to store the (row,col,flip,score)
	for explore in successor(row,col,maze,flip):
		if length of list generated from successor is 0 and not 'FinalNode':
			score = 0 
			continue
		if the value of explore in the maze is 'F':
			score = 2
		if length of list generated from successor is greater than 0 and not 'FinalNode':
			score = 1
		flip = explore's flip boolean value
		scoreList.append(explore's row value,explore's column value, explores flip boolean value, score)
	import itemgetter from operator to sort the scoreList
	scoreList = sorted(scoreList bease on score in ascending order) //_in stack LIFO value needs to be highest_
	return scoreList

// __searching the local connected noted, we are also calling the ConstrainPropagation function__
def LocalSearch(row, column, maze):
	set Flip = False (_starting with head direction_)
	score = 0 (_starting with score 0_)
	start node construct = ([row, col, flip, score])
	initiate visited list
	creating a stack with [(start,[start])] // _one used as node pointer and one as path_
	intiating steps
	while stack exists:
		currentNode and path = stack.pop()
		if the currentNode is visited:
			continue
		add currentNode to visisted
		if maze[current] == 'F': // _if the current node is finish node_
			return path, score
		if (length of path) == 1:
			for node in constrainProp(currentNode, maze, flip):
			// _(for a node from the list generated by the function ConstrainProp()_)
			stack.append(node, path+[node])
			steps increment for count
		elif(length of path) > 1:
			flip = currentNode[2] // (_at index 2 of currentNode we store the Flip boolean value of every Node_)
			stack.append((node, path+[node])
			steps increment for decisions made
	return [], steps

// __finding the succsessors for the node__
def successor(row, column, maze, flip):
	initializing Successor list
	if flip is false: (_if the parent node used its tail direction_)
		set flip to True (_use head direction_)
		if dir == 'N':
			get elements in north within maze
			append to successor list
		if dir == 'S':
			get elements in south within maze
			append to successor list
		if dir == 'E':
			get elements in  east within maze
			append to successor list
		if dir == 'W':
			get elements in  west within maze
			append to successor list
		if dir == 'NE':
			get elements in NorthEast within maze
			append to successor list
		if dir == 'NW':
			get elements in NorthWest within maze
			append to successor list
		if dir == 'SE':
			get elements in SouthEast within maze
			append to successor list
		if dir == 'SW':
			get elements in SouthWest within maze
			append to successor list
		return successors
	if flip is True: (_if the parent node used its Head direction_)
		set flip to Flip (_use Tail direction_)
		if dir == 'N':
			get elements in South within maze
			append to successor list
		if dir == 'S':
			get elements in North within maze
			append to successor list
		if dir == 'E':
			get elements in West within maze
			append to successor list
		if dir == 'W':
			get elements in  East within maze
			append to successor list
		if dir == 'NE':
			get elements in SouthWest within maze
			append to successor list
		if dir == 'NW':
			get elements in SouthEast within maze
			append to successor list
		if dir == 'SE':
			get elements in NorthWest within maze
			append to successor list
		if dir == 'SW':
			get elements in NorthEast within maze
			append to successor list
		return Successors

// __creating the maze__
def create:
	size = input size of matrix 
	maze = storing maze as list

// __creating main function calling LocalSearch__
def main():
	maze = create()
	path, cost = LocalSearch(startingNodeRow, startingNodeCol, maze)	
	for looping to convert the node address in maze to direction for representation

def if name == main:
	calling main()